<!DOCTYPE html>
<html>
<head>
<title>JS car</title>
</head>
<body>
<svg width="500" height="500">
</svg>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.9.0/d3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/5.4.2/math.min.js"></script>
<script>

const LOG_SOME = (() => {
  let counter = 0;
  return function() {
    if (counter++ < 1000) console.log(...arguments);
  };
})();

function Car() {
  this.length = 3;
  this.width = 2;

  this.mass = 1000.0; // kg
  this.moi = 1/12 * (this.length*this.length + this.width * this.width) * this.mass;

  //this.cmBalance = -0.2;

  this.pos = [0, 0];
  this.rot = -Math.PI * 0.5;

  this.v = [0, 10];
  this.vrot = 0.0; //1.0;

  this.backSlip = false;
  this.frontSlip = false;

  let wheelAngle = 0.0;

  const MIN_TURNING_RADIUS = 3;
  const MAX_WHEEL_ANGLE = Math.atan(this.length / MIN_TURNING_RADIUS);
  const WHEEL_TURN_SPEED = 0.5; // 2.0; // radians / sec
  const AIR_RES_COEFF = this.mass * 0.1;
  const GRAVITY = 9.81;
  const STATIC_FRICTION = 0.9;
  const DYNAMIC_FRICTION = 0.5;

  const M = [
    [this.mass, 0, 0],
    [0, this.mass, 0],
    [0, 0, this.moi]
  ];

  const Minv = math.inv(M);

  function cross2d(x, y) {
    return x[0]*y[1] - y[0]*x[1];
  }

  function norm(vec) {
    return Math.sqrt(math.dot(vec, vec));
  }

  function normalize(vec) {
    return math.multiply(vec, 1.0 / norm(vec));
  }

  function rot90cw(vec) {
    return [vec[1], -vec[0]];
  }

  function rot90ccw(vec) {
    return [-vec[1], vec[0]];
  }

  console.log('-----begin-----');

  const curControls = {};

  const keymap = {
    37: 'left',
    39: 'right',
    38: 'throttle',
    40: 'brake'
  };

  document.onkeydown = function(e) {
    if (keymap[e.keyCode]) {
      curControls[keymap[e.keyCode]] = true;
    }
  };

  document.onkeyup = function(e) {
    if (keymap[e.keyCode]) {
      curControls[keymap[e.keyCode]] = false;
    }
  };

  this.move = (dt) => {
    if (dt == 0.0 || dt > 1.0) return;
    //dt *= 0.1;

    //console.log(curControls);

    const v0 = [this.v[0], this.v[1], this.vrot];

    //this.pos = math.add(this.pos, math.multiply(this.v, dt));
    //this.rot += this.vrot * dt;

    // local coordinates
    const fwd = [Math.cos(this.rot), Math.sin(this.rot)];
    const right = rot90cw(fwd);

    const back = math.multiply(fwd, -this.length*0.5);
    const front = math.multiply(fwd, this.length*0.5);

    let targetWheelAngle = 0.0;
    if (curControls.left) {
      targetWheelAngle = -MAX_WHEEL_ANGLE;
    } else if (curControls.right) {
      targetWheelAngle = MAX_WHEEL_ANGLE;
    } else {
      targetWheelAngle = 0.0;
    }

    if (wheelAngle != targetWheelAngle) {
      const diff = targetWheelAngle - wheelAngle;
      const maxDelta = dt * WHEEL_TURN_SPEED;
      wheelAngle += Math.sign(diff) * Math.min(Math.abs(diff), maxDelta);
    }

    let frontWheelAxis = right;
    if (wheelAngle != 0.0) {
      const turningRadius = this.length / Math.tan(wheelAngle);
      const turningCenter = math.add(back, math.multiply(right, turningRadius));
      //console.log(wheelAngle, turningRadius);
      frontWheelAxis = normalize(math.subtract(turningCenter, front));
    }

    let thrust = 0.0;
    const maxThrust = this.mass * 0.7 * GRAVITY * 0.5;
    if (curControls.throttle) {
      thrust = -maxThrust;
    }
    else if (curControls.brake) {
      thrust = maxThrust;
    }

    // solve velocity constraints

    // solve forces (no slip)
    const backWheelAxis = right;

    // external forces
    const resistance = math.multiply(this.v, -AIR_RES_COEFF);
    const externalForces = resistance;

    const solveForcesNoSlip = () => {

        //LOG_SOME({frontWheelAxis,backWheelAxis});

        // TODO: this form does not strictly conserve energy!
        const KFperMdt = math.multiply(dt / this.mass, math.transpose([frontWheelAxis, backWheelAxis]));
        const kTauPerMdt = math.multiply(dt / this.moi, [[cross2d(front, frontWheelAxis), cross2d(back, backWheelAxis)]]);
        const tauVFront = math.transpose([rot90cw(front)]);
        const tauVBack = math.transpose([rot90cw(back)]);

        //console.log([frontWheelAxis]);
        //console.log(math.add(KFperMdt, math.multiply(tauVFront, kTauPerMdt)));

        const aFront = math.multiply(
          [frontWheelAxis],
          math.add(KFperMdt, math.multiply(tauVFront, kTauPerMdt)));
        const aBack = math.multiply(
          [backWheelAxis],
          math.add(KFperMdt, math.multiply(tauVBack, kTauPerMdt)));

        const thrustForce = math.multiply(thrust, fwd);
        const F0perMdt = math.multiply(dt / this.mass, math.add(externalForces, thrustForce));

        const bFront = -math.dot(frontWheelAxis, math.add(
          F0perMdt,
          this.v,
          math.multiply(rot90cw(front), this.vrot))
        );
        const bBack = -math.dot(backWheelAxis, math.add(
          F0perMdt,
          this.v,
          math.multiply(rot90cw(back), this.vrot))
        );

        const A = [aFront[0], aBack[0]];
        const b = [bFront, bBack];

        //console.log({dt, vrot: this.vrot});
        //console.log({vrot: this.vrot, v: this.v, tcp: turningCenterPerp})
        //LOG_SOME({A,b});

        const forceCoeffs = math.lusolve(A, b);
        //LOG_SOME(forceCoeffs);

        const forceFront = forceCoeffs[0][0];
        const forceBack = forceCoeffs[1][0];

        //console.log({forceFront, forceBack});

        return [
          math.multiply(forceFront, frontWheelAxis),
          math.add(math.multiply(forceBack, backWheelAxis), thrustForce)
        ];
    }

    const solveForcesSemiSlip = (point, axis, externalF, externalT) => {
        const KFperMdt = math.multiply(dt / this.mass, math.transpose([axis]));
        const kTauPerMdt = math.multiply(dt / this.moi, [[cross2d(point, axis)]]);
        const tauV = math.transpose([rot90cw(point)]);
        const a = math.multiply([axis], math.add(KFperMdt, math.multiply(tauV, kTauPerMdt)));

        //LOG_SOME({point, axis, externalF, externalT});

        //const thrustForce = math.multiply(thrust, fwd);
        const F0perMdt = math.multiply(dt / this.mass, externalF);
        const bb = -math.dot(axis, math.add(
          F0perMdt,
          this.v,
          math.multiply(rot90cw(point), this.vrot + dt * externalT / this.moi))
        );

        const A = [a[0]];
        const b = [bb];

        //console.log({dt, vrot: this.vrot});
        //console.log({vrot: this.vrot, v: this.v, tcp: turningCenterPerp})
        //console.log({A,b});

        // TODO: no need for lusolve here
        const forceCoeffs = math.lusolve(A, b);
        return math.multiply(forceCoeffs[0][0], axis);
    }

    const solveForces = () => {
      const backFriction = this.backSlip ? DYNAMIC_FRICTION : STATIC_FRICTION;
      const frontFriction = this.frontSlip ? DYNAMIC_FRICTION : STATIC_FRICTION;
      const maxForceBack = this.mass * GRAVITY * backFriction / 2.0;
      const maxForceFront = this.mass * GRAVITY * frontFriction / 2.0;

      let [forceFront, forceBack] = solveForcesNoSlip();
      //console.log(forceFront, forceBack);
      this.backSlip = norm(forceBack) > maxForceBack;
      this.frontSlip = norm(forceFront) > maxForceFront;

      //console.log(norm(forceFront), maxForce);

      if (this.backSlip || this.frontSlip) {

        LOG_SOME(`maxForce: ${maxForceFront},${maxForceBack} ${norm(forceFront)},${norm(forceBack)}`);
        const maxForceSlip = this.mass * GRAVITY * DYNAMIC_FRICTION / 2.0;

        const frontVel = math.add(this.v, math.multiply(rot90cw(front), this.vrot));
        const backVel = math.add(this.v, math.multiply(rot90cw(back), this.vrot));
        //const backSlippy = math.multiply(normalize(frontVel), -maxForce);
        //const frontSlippy = math.multiply(normalize(backVel), -maxForce);
        const backSlippy = math.multiply(normalize(forceBack), maxForceSlip);
        const frontSlippy = math.multiply(normalize(forceFront), maxForceSlip);

        forceFront = frontSlippy;
        forceBack = backSlippy;

        if (this.backSlip && !this.frontSlip) {
          forceFront = solveForcesSemiSlip(front, frontWheelAxis, math.add(backSlippy, externalForces), cross2d(back, backSlippy));
          this.frontSlip = norm(forceFront) > maxForceFront;
          if (this.frontSlip) {
            forceFront = frontSlippy;
          }
        }
        else if (this.frontSlip && !this.backSlip) {
          forceBack = solveForcesSemiSlip(back, backWheelAxis, math.add(frontSlippy, externalForces), cross2d(front, frontSlippy));
          this.backSlip = norm(forceBack) > maxForceBack;
          if (this.backSlip) {
            forceBack = backSlippy;
          }
        }
        LOG_SOME(this.frontSlip, this.backSlip);
      }

      return [forceFront, forceBack];
    }

    const [forceFront, forceBack] = solveForces();

    const totalForce = math.add(externalForces, forceFront, forceBack);
    const totalTorque = cross2d(front, forceFront) + cross2d(back, forceBack);

    //console.log({totalForce, totalTorque});
    //console.log(math.multiply(dt, math.multiply(Minv, [totalForce[0], totalForce[1], totalTorque])));

    const deltaV = math.multiply(dt, math.multiply(Minv, [totalForce[0], totalForce[1], totalTorque]));
    //const deltaV = vDiff;

    //console.log(deltaV);

    //console.log(`energy: ${E0}`);

    // integrate position
    this.pos = math.add(this.pos, math.multiply(this.v, dt));
    this.rot += this.vrot * dt;

    const [vx, vy, vrot] = math.add(v0, deltaV);
    this.v = [vx, vy];
    this.vrot = vrot;
    //console.log(vrot);
  };
}

function render(car, svg) {
  const s = 10.0;
  const [origX, origY] = [250, 250]
  svg.selectAll('g').remove();

  const carCoords = svg
    .append('g')
    .attr('transform', `
      translate(
        ${car.pos[0]*s+origX},
        ${500-car.pos[1]*s-origY})
      rotate(${90-car.rot/Math.PI*180.0})`)
    .append('g')
    .attr('transform', `scale(${s})`);

  carCoords
    .append('rect')
      .attr('x', -car.width*0.5)
      .attr('y', -car.length*0.5)
      .attr('width', car.width)
      .attr('height', car.length)
      .attr('fill', 'green');

  [true, false].forEach(isFront => {
    const endSign = isFront ? 1 : -1;
    const slip = isFront ? car.frontSlip : car.backSlip;
    const color = slip ? 'red' : (isFront ? 'gray' : 'black');

    [-1,1].forEach(side => {
      carCoords
        .append('g')
        .attr('transform', `translate(${car.width*0.5*side}, ${car.length*0.5*endSign})`)
        .append('circle')
          .attr('r', car.width*0.2)
          .attr('fill', color);
    });
  });
}


const car = new Car();
const svg = d3.select('svg');
let t = new Date();

function draw() {

  const t0 = t;
  t = new Date();
  const dt = (t - t0) * 1e-3;
  car.move(dt);

  render(car, svg);
  requestAnimationFrame(draw);
}
draw();

</script>
</body>
</html>
